{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Geobay","text":"<p>python package for geog 510</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://Caseyshea96.github.io/GeoBay</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>TODO</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>```{python} import geobay</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/Caseyshea96/geoproject510/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>GeoProject510 could always use more documentation, whether as part of the official GeoProject510 docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/Caseyshea96/geoproject510/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up geoproject510 for local development.</p> <ol> <li> <p>Fork the geoproject510 repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/geoproject510.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv geoproject510\n$ cd geoproject510/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 geoproject510 tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/Caseyshea96/geoproject510/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"foliumap/","title":"foliumap module","text":""},{"location":"foliumap/#GeoBay.foliumap.FoliumMap","title":"<code>FoliumMap</code>","text":"Source code in <code>GeoBay\\foliumap.py</code> <pre><code>class FoliumMap:\n    def __init__(self, location, zoom_start=3, **kwargs):\n        \"\"\"\n        Initializes a folium map centered at a given location with a specified zoom level.\n\n        Parameters:\n        location (tuple): Latitude and longitude coordinates for the map center.\n        zoom_start (int): The initial zoom level of the map.\n        \"\"\"\n        self.map = folium.Map(location=location, zoom_start=zoom_start, **kwargs)\n\n    def add_basemap(self, basemap='OpenStreetMap'):\n        \"\"\"\n        Adds a basemap to the folium map.\n\n        Parameters:\n        basemap (str): The name of the basemap to add (e.g., 'OpenStreetMap', 'Stamen Terrain', etc.).\n        \"\"\"\n        basemaps = {\n            'OpenStreetMap': 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n            'Stamen Terrain': 'http://{s}.tile.stamen.com/terrain/{z}/{x}/{y}.jpg',\n            'Esri WorldImagery': 'http://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'\n        }\n        folium.TileLayer(tiles=basemaps.get(basemap, basemaps['OpenStreetMap']), attr=basemap).add_to(self.map)\n\n    def add_layer_control(self):\n        \"\"\"\n        Adds a layer control widget to the folium map for toggling layers.\n        \"\"\"\n        folium.LayerControl().add_to(self.map)\n\n    def add_vector(self, geo_data):\n        \"\"\"\n        Adds vector data (GeoJSON or other formats supported by GeoPandas) to the map.\n\n        Parameters:\n        geo_data (GeoDataFrame or str): A GeoDataFrame or a path to a GeoJSON file.\n        \"\"\"\n        if isinstance(geo_data, gpd.GeoDataFrame):\n            geo_data = geo_data.to_json()\n        folium.GeoJson(geo_data).add_to(self.map)\n\n    def add_split_map(self, left_layer='OpenStreetMap', right_layer='Stamen Terrain'):\n        \"\"\"\n        Adds a side-by-side split view of two different tile layers.\n\n        Parameters:\n        left_layer (str): Basemap name for the left side.\n        right_layer (str): Basemap name for the right side.\n        \"\"\"\n        # Define the basemap options\n        basemaps = {\n            'OpenStreetMap': folium.TileLayer(\n                tiles='https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n                name='OpenStreetMap', attr='OpenStreetMap'\n            ),\n            'Stamen Terrain': folium.TileLayer(\n                tiles='http://{s}.tile.stamen.com/terrain/{z}/{x}/{y}.jpg',\n                name='Stamen Terrain', attr='Stamen Terrain'\n            ),\n            'Esri WorldImagery': folium.TileLayer(\n                tiles='http://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',\n                name='Esri WorldImagery', attr='Esri WorldImagery'\n            )\n        }\n\n        # Get the left and right basemaps\n        left = basemaps.get(left_layer, basemaps['OpenStreetMap'])\n        right = basemaps.get(right_layer, basemaps['Stamen Terrain'])\n\n        # Add the layers to the map\n        left.add_to(self.map)\n        right.add_to(self.map)\n\n        # Add the side-by-side split functionality\n        side_by_side = SideBySideLayers(left, right)\n        side_by_side.add_to(self.map)\n\n    def show_map(self):\n        \"\"\"\n        Displays the folium map in the Jupyter notebook or Python script.\n        \"\"\"\n        return self.map\n</code></pre>"},{"location":"foliumap/#GeoBay.foliumap.FoliumMap.__init__","title":"<code>__init__(location, zoom_start=3, **kwargs)</code>","text":"<p>Initializes a folium map centered at a given location with a specified zoom level.</p> <p>Parameters: location (tuple): Latitude and longitude coordinates for the map center. zoom_start (int): The initial zoom level of the map.</p> Source code in <code>GeoBay\\foliumap.py</code> <pre><code>def __init__(self, location, zoom_start=3, **kwargs):\n    \"\"\"\n    Initializes a folium map centered at a given location with a specified zoom level.\n\n    Parameters:\n    location (tuple): Latitude and longitude coordinates for the map center.\n    zoom_start (int): The initial zoom level of the map.\n    \"\"\"\n    self.map = folium.Map(location=location, zoom_start=zoom_start, **kwargs)\n</code></pre>"},{"location":"foliumap/#GeoBay.foliumap.FoliumMap.add_basemap","title":"<code>add_basemap(basemap='OpenStreetMap')</code>","text":"<p>Adds a basemap to the folium map.</p> <p>Parameters: basemap (str): The name of the basemap to add (e.g., 'OpenStreetMap', 'Stamen Terrain', etc.).</p> Source code in <code>GeoBay\\foliumap.py</code> <pre><code>def add_basemap(self, basemap='OpenStreetMap'):\n    \"\"\"\n    Adds a basemap to the folium map.\n\n    Parameters:\n    basemap (str): The name of the basemap to add (e.g., 'OpenStreetMap', 'Stamen Terrain', etc.).\n    \"\"\"\n    basemaps = {\n        'OpenStreetMap': 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n        'Stamen Terrain': 'http://{s}.tile.stamen.com/terrain/{z}/{x}/{y}.jpg',\n        'Esri WorldImagery': 'http://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'\n    }\n    folium.TileLayer(tiles=basemaps.get(basemap, basemaps['OpenStreetMap']), attr=basemap).add_to(self.map)\n</code></pre>"},{"location":"foliumap/#GeoBay.foliumap.FoliumMap.add_layer_control","title":"<code>add_layer_control()</code>","text":"<p>Adds a layer control widget to the folium map for toggling layers.</p> Source code in <code>GeoBay\\foliumap.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"\n    Adds a layer control widget to the folium map for toggling layers.\n    \"\"\"\n    folium.LayerControl().add_to(self.map)\n</code></pre>"},{"location":"foliumap/#GeoBay.foliumap.FoliumMap.add_split_map","title":"<code>add_split_map(left_layer='OpenStreetMap', right_layer='Stamen Terrain')</code>","text":"<p>Adds a side-by-side split view of two different tile layers.</p> <p>Parameters: left_layer (str): Basemap name for the left side. right_layer (str): Basemap name for the right side.</p> Source code in <code>GeoBay\\foliumap.py</code> <pre><code>def add_split_map(self, left_layer='OpenStreetMap', right_layer='Stamen Terrain'):\n    \"\"\"\n    Adds a side-by-side split view of two different tile layers.\n\n    Parameters:\n    left_layer (str): Basemap name for the left side.\n    right_layer (str): Basemap name for the right side.\n    \"\"\"\n    # Define the basemap options\n    basemaps = {\n        'OpenStreetMap': folium.TileLayer(\n            tiles='https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n            name='OpenStreetMap', attr='OpenStreetMap'\n        ),\n        'Stamen Terrain': folium.TileLayer(\n            tiles='http://{s}.tile.stamen.com/terrain/{z}/{x}/{y}.jpg',\n            name='Stamen Terrain', attr='Stamen Terrain'\n        ),\n        'Esri WorldImagery': folium.TileLayer(\n            tiles='http://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',\n            name='Esri WorldImagery', attr='Esri WorldImagery'\n        )\n    }\n\n    # Get the left and right basemaps\n    left = basemaps.get(left_layer, basemaps['OpenStreetMap'])\n    right = basemaps.get(right_layer, basemaps['Stamen Terrain'])\n\n    # Add the layers to the map\n    left.add_to(self.map)\n    right.add_to(self.map)\n\n    # Add the side-by-side split functionality\n    side_by_side = SideBySideLayers(left, right)\n    side_by_side.add_to(self.map)\n</code></pre>"},{"location":"foliumap/#GeoBay.foliumap.FoliumMap.add_vector","title":"<code>add_vector(geo_data)</code>","text":"<p>Adds vector data (GeoJSON or other formats supported by GeoPandas) to the map.</p> <p>Parameters: geo_data (GeoDataFrame or str): A GeoDataFrame or a path to a GeoJSON file.</p> Source code in <code>GeoBay\\foliumap.py</code> <pre><code>def add_vector(self, geo_data):\n    \"\"\"\n    Adds vector data (GeoJSON or other formats supported by GeoPandas) to the map.\n\n    Parameters:\n    geo_data (GeoDataFrame or str): A GeoDataFrame or a path to a GeoJSON file.\n    \"\"\"\n    if isinstance(geo_data, gpd.GeoDataFrame):\n        geo_data = geo_data.to_json()\n    folium.GeoJson(geo_data).add_to(self.map)\n</code></pre>"},{"location":"foliumap/#GeoBay.foliumap.FoliumMap.show_map","title":"<code>show_map()</code>","text":"<p>Displays the folium map in the Jupyter notebook or Python script.</p> Source code in <code>GeoBay\\foliumap.py</code> <pre><code>def show_map(self):\n    \"\"\"\n    Displays the folium map in the Jupyter notebook or Python script.\n    \"\"\"\n    return self.map\n</code></pre>"},{"location":"geobay/","title":"GeoBay module","text":""},{"location":"geobay/#GeoBay.GeoBay.gb_map","title":"<code>gb_map</code>","text":"<p>               Bases: <code>Map</code></p> <p>A custom wrapper around ipyleaflet.Map with additional helper methods for adding basemaps, vector data, raster layers, images, videos, and WMS layers.</p> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>class gb_map(IpyleafletMap):\n    \"\"\"\n    A custom wrapper around ipyleaflet.Map with additional helper methods\n    for adding basemaps, vector data, raster layers, images, videos, and WMS layers.\n    \"\"\"\n\n    def __init__(self, center, zoom=12, **kwargs):\n        \"\"\"\n        Initialize the custom map.\n\n        Args:\n            center (tuple): Latitude and longitude of the map center.\n            zoom (int, optional): Zoom level of the map. Defaults to 12.\n            **kwargs: Additional keyword arguments for ipyleaflet.Map.\n        \"\"\"\n        kwargs.setdefault(\"scroll_wheel_zoom\", True)\n        super().__init__(center=center, zoom=zoom, **kwargs)\n\n    def add_basemap(self, basemap_name: str):\n        \"\"\"\n        Add a basemap layer to the map.\n\n        Args:\n            basemap_name (str): Name of the basemap ('OpenStreetMap', 'Esri.WorldImagery', or 'OpenTopoMap').\n\n        Raises:\n            ValueError: If the basemap name is not supported.\n        \"\"\"\n        basemap_urls = {\n            \"OpenStreetMap\": \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\",\n            \"Esri.WorldImagery\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n            \"OpenTopoMap\": \"https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png\"\n        }\n\n        if basemap_name not in basemap_urls:\n            raise ValueError(f\"Basemap '{basemap_name}' is not supported.\")\n\n        basemap = TileLayer(url=basemap_urls[basemap_name])\n        self.add_layer(basemap)\n\n    def add_basemap_gui(self, options=None, position=\"topright\"):    \n        \"\"\"\n        Adds a graphical user interface (GUI) for selecting basemaps.\n\n        Args:\n            -options (list, optional): A list of basemap options to display in the dropdown.\n               [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"CartoDB.DarkMatter\"].\n            -position (str, optional): The position of the widget on the map. Defaults to \"topright\".\n\n        Behavior:\n            - A toggle button is used to show or hide the dropdown and close button.\n            - The dropdown allows users to select a bsemap from the provided options.\n            - The close button hides the widget from the map.\n\n        Event Handlers:\n            - `on_toggle_change`: Toggles the visibility of the dropdown and close button.\n            - `on_button_click`: Closes the widget when button is clicked\n            - `on_dropdown_change`: Updates the basemap when a new option is selected.\n        \"\"\"\n        if options is None:\n            options = [\n                \"OpenStreetMap.Mapnik\",\n                \"OpenTopoMap\",\n                \"Esri.WorldImagery\",\n                \"CartoDB.DarkMatter\",\n            ]\n\n        toggle = widgets.ToggleButton(\n            value=True,\n            button_style=\"\",\n            tooltip=\"Click me\",\n            icon=\"map\",\n        )\n        toggle.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n        dropdown = widgets.Dropdown(\n            options=options,\n            value=options[0],\n            description=\"Basemap:\",\n            style={\"description_width\": \"initial\"},\n        )\n        dropdown.layout = widgets.Layout(width=\"250px\", height=\"38px\")\n\n        button = widgets.Button(\n            icon=\"times\",\n        )\n        button.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n        hbox = widgets.HBox([toggle, dropdown, button])\n\n        def on_toggle_change(change):\n            if change[\"new\"]:\n                hbox.children = [toggle, dropdown, button]\n            else:\n                hbox.children = [toggle]\n\n        toggle.observe(on_toggle_change, names=\"value\")\n\n        def on_button_click(b):\n            hbox.close()\n            toggle.close()\n            dropdown.close()\n            button.close()\n\n        button.on_click(on_button_click)\n\n        def on_dropdown_change(change):\n            if change[\"new\"]:\n                self.layers = self.layers[:-2]\n                self.add_basemap(change[\"new\"])\n\n        dropdown.observe(on_dropdown_change, names=\"value\")\n\n        control = WidgetControl(widget=hbox, position=position)\n        self.add(control)\n\n    def add_widget(self, widget, position=\"topright\", **kwargs):\n        \"\"\"Add a widget to the map.\n\n        Args:\n            widget (ipywidgets.Widget): The widget to add.\n            position (str, optional): Position of the widget. Defaults to \"topright\".\n            **kwargs: Additional keyword arguments for the WidgetControl.\n        \"\"\"\n        control = ipyleaflet.WidgetControl(widget=widget, position=position, **kwargs)\n        self.add(control)\n\n\n    def add_vector(self, vector_data):\n        \"\"\"\n        Add a vector layer to the map from a file path or GeoDataFrame.\n\n        Args:\n            vector_data (str or geopandas.GeoDataFrame): Path to a vector file or a GeoDataFrame.\n\n        Raises:\n            ValueError: If the input is not a valid file path or GeoDataFrame.\n        \"\"\"\n        if isinstance(vector_data, str):\n            gdf = gpd.read_file(vector_data)\n        elif isinstance(vector_data, gpd.GeoDataFrame):\n            gdf = vector_data\n        else:\n            raise ValueError(\"Input must be a file path or a GeoDataFrame.\")\n\n        geo_json_data = gdf.__geo_interface__\n        geo_json_layer = GeoJSON(data=geo_json_data)\n        self.add_layer(geo_json_layer)\n\n    def add_raster(self, url, name=None, colormap=None, opacity=1.0):\n        \"\"\"\n        Add a raster tile layer to the map.\n\n        Args:\n            url (str): URL template for the raster tiles.\n            name (str, optional): Layer name. Defaults to \"Raster Layer\".\n            colormap (optional): Colormap to apply (not used here but reserved).\n            opacity (float, optional): Opacity of the layer (0.0 to 1.0). Defaults to 1.0.\n        \"\"\"\n        tile_layer = TileLayer(\n            url=url,\n            name=name or \"Raster Layer\",\n            opacity=opacity\n        )\n        self.add_layer(tile_layer)\n\n    def add_image(self, url, bounds, opacity=1.0):\n        \"\"\"\n        Add an image overlay to the map.\n\n        Args:\n            url (str): URL of the image.\n            bounds (list): Bounding box of the image [[south, west], [north, east]].\n            opacity (float, optional): Opacity of the image. Defaults to 1.0.\n        \"\"\"\n        image_layer = ImageOverlay(\n            url=url,\n            bounds=bounds,\n            opacity=opacity\n        )\n        self.add_layer(image_layer)\n\n    def add_video(self, url, bounds, opacity=1.0):\n        \"\"\"\n        Add a video overlay to the map.\n\n        Args:\n            url (str): URL of the video.\n            bounds (list): Bounding box for the video [[south, west], [north, east]].\n            opacity (float, optional): Opacity of the video. Defaults to 1.0.\n        \"\"\"\n        video_layer = VideoOverlay(\n            url=url,\n            bounds=bounds,\n            opacity=opacity\n        )\n        self.add_layer(video_layer)\n\n    def add_wms_layer(self, url, layers, name=None, format='image/png', transparent=True, **extra_params):\n        \"\"\"\n        Add a WMS (Web Map Service) layer to the map.\n\n        Args:\n            url (str): WMS base URL.\n            layers (str): Comma-separated list of layer names.\n            name (str, optional): Display name for the layer. Defaults to \"WMS Layer\".\n            format (str, optional): Image format. Defaults to 'image/png'.\n            transparent (bool, optional): Whether the background is transparent. Defaults to True.\n            **extra_params: Additional parameters to pass to the WMSLayer.\n        \"\"\"\n        wms_layer = WMSLayer(\n            url=url,\n            layers=layers,\n            name=name or \"WMS Layer\",\n            format=format,\n            transparent=transparent,\n            **extra_params\n        )\n        self.add_layer(wms_layer)\n\n    def show_map(self):\n        \"\"\"\n        Display the map in a Jupyter notebook or compatible environment.\n\n        Returns:\n            ipyleaflet.Map: The configured map.\n        \"\"\"\n        return self\n\n    def add_search_control(self, position=\"topleft\", zoom=10):\n        \"\"\"\n        Add a search bar to the map using Nominatim geocoder.\n        \"\"\"\n        search = SearchControl(\n            position=position,\n            url='https://nominatim.openstreetmap.org/search?format=json&amp;q={s}',\n            zoom=zoom,\n            marker=Marker()  # \u2705 Provide a valid Marker object\n        )\n        self.add_control(search)\n\n\n    def add_esa_worldcover(self, position=\"bottomright\"):\n        import ipywidgets as widgets\n        from ipyleaflet import WMSLayer, WidgetControl\n        import leafmap\n\n        esa_layer = WMSLayer(\n            url=\"https://services.terrascope.be/wms/v2?\",\n            layers=\"WORLDCOVER_2021_MAP\",\n            name=\"ESA WorldCover 2021\",\n            transparent=True,\n            format=\"image/png\"\n        )\n        self.add_layer(esa_layer)\n\n        legend_dict = leafmap.builtin_legends['ESA_WorldCover']\n\n        def format_legend_html(legend_dict, title=\"ESA WorldCover Legend\"):\n            html = f\"&lt;div style='padding:10px;background:white;font-size:12px'&gt;&lt;b&gt;{title}&lt;/b&gt;&lt;br&gt;\"\n            for label, color in legend_dict.items():\n                html += f\"&lt;span style='color:#{color}'&gt;\u25a0&lt;/span&gt; {label}&lt;br&gt;\"\n            html += \"&lt;/div&gt;\"\n            return html\n\n        legend_html = format_legend_html(legend_dict)\n        legend_widget = widgets.HTML(value=legend_html)\n        legend_control = WidgetControl(widget=legend_widget, position=position)\n        self.add_control(legend_control)\n\n    def add_circle_markers_from_xy(self, gdf, radius=5, color=\"red\", fill_color=\"yellow\", fill_opacity=0.8):\n        \"\"\"\n        Add circle markers from a GeoDataFrame with lat/lon columns using MarkerCluster.\n\n        Args:\n            gdf (GeoDataFrame): Must contain 'latitude' and 'longitude' columns.\n            radius (int): Radius of each marker.\n            color (str): Outline color.\n            fill_color (str): Fill color.\n            fill_opacity (float): Fill opacity.\n        \"\"\"\n        if 'latitude' not in gdf.columns or 'longitude' not in gdf.columns:\n            raise ValueError(\"GeoDataFrame must contain 'latitude' and 'longitude' columns\")\n\n        markers = []\n        for _, row in gdf.iterrows():\n            marker = CircleMarker(\n                location=(row['latitude'], row['longitude']),\n                radius=radius,\n                color=color,\n                fill_color=fill_color,\n                fill_opacity=fill_opacity,\n                stroke=True\n            )\n            markers.append(marker)\n\n        cluster = MarkerCluster(markers=markers)\n        self.add_layer(cluster)\n\n    def add_choropleth(self, url, column, colormap=\"YlOrRd\"):\n        \"\"\"\n        Simulate a choropleth using GeoJSON layer and dynamic styling.\n\n        Args:\n            url (str): GeoJSON file URL.\n            column (str): Attribute column to color by.\n            colormap (str): Color ramp name (from branca.colormap).\n        \"\"\"\n        import branca.colormap as cm\n        import json\n\n        gdf = gpd.read_file(url)\n        gdf = gdf.to_crs(\"EPSG:4326\")\n        gdf[\"id\"] = gdf.index.astype(str)\n\n        values = gdf[column]\n        cmap = cm.linear.__getattribute__(colormap).scale(values.min(), values.max())\n\n        def style_dict(feature):\n            value = gdf.loc[int(feature['id']), column]\n            return {\n                'fillColor': cmap(value),\n                'color': 'black',\n                'weight': 0.5,\n                'fillOpacity': 0.7\n            }\n\n        geo_json = json.loads(gdf.to_json())\n        layer = GeoJSON(\n            data=geo_json,\n            style={\n                'color': 'black',\n                'fillColor': 'blue',\n                'weight': 0.5,\n                'fillOpacity': 0.7\n            },\n            name=\"Choropleth\"\n        )\n        self.add_layer(layer)\n\n    def add_split_rasters_leafmap(self, pre_url, post_url, pre_name=\"Pre-event\", post_name=\"Post-event\", overwrite=True):\n        \"\"\"\n        Use leafmap to split and visualize two remote raster .tif files.\n        \"\"\"\n        import leafmap\n        import rasterio\n        import os\n\n        def download_and_check(url, path):\n            file = leafmap.download_file(url, path, overwrite=overwrite)  # \u2705 Ensure overwrite is passed here\n            try:\n                with rasterio.open(file) as src:\n                    _ = src.meta\n                return file\n            except Exception as e:\n                raise ValueError(f\"{path} is not a valid GeoTIFF: {e}\")\n\n        pre_tif = download_and_check(pre_url, \"pre_event.tif\")\n        post_tif = download_and_check(post_url, \"post_event.tif\")\n\n        m = leafmap.Map(center=self.center, zoom=self.zoom)\n        m.split_map(left_layer=pre_tif, right_layer=post_tif, left_label=pre_name, right_label=post_name)\n        return m\n\n    def add_building_polygons(self, url):\n        \"\"\"\n        Add building polygons with red outline and no fill.\n        \"\"\"\n        gdf = gpd.read_file(url)\n        geo_json = gdf.__geo_interface__\n\n        style = {\n            \"color\": \"red\",\n            \"weight\": 1,\n            \"fill\": False,\n            \"fillOpacity\": 0.0\n        }\n\n        self.add_layer(GeoJSON(data=geo_json, style=style, name=\"Buildings\"))\n\n    def add_roads(self, url):\n        \"\"\"\n        Add road polylines with red color and width 2.\n        \"\"\"\n        gdf = gpd.read_file(url)\n        geo_json = gdf.__geo_interface__\n\n        style = {\n            \"color\": \"red\",\n            \"weight\": 2,\n            \"opacity\": 1.0\n        }\n\n    def add_ee_layer(self, ee_object, vis_params=None, name=None):\n        \"\"\"\n        Add an Earth Engine object to the ipyleaflet map.\n\n        Parameters\n        ----------\n        ee_object : ee.Image or ee.FeatureCollection\n            The Earth Engine object to display.\n        vis_params : dict, optional\n            Visualization parameters.\n        name : str, optional\n            Layer name for the legend and layer control.\n        \"\"\"\n        import geemap\n        layer = geemap.ee_tile_layer(ee_object, vis_params, name)\n        self.add_layer(layer)\n\n\n    def enable_draw_bbox(self, elevation_threshold=10, post_action=None, accumulation_threshold=1000):\n        from ipyleaflet import DrawControl\n        import ipywidgets as widgets\n        from IPython.display import display\n        import ee\n        from . import hydro\n\n        if hasattr(self, 'draw_control') and self.draw_control in self.controls:\n            self.remove_control(self.draw_control)\n\n        draw_control = DrawControl(rectangle={\"shapeOptions\": {\"color\": \"#0000FF\"}})\n        draw_control.polygon = {}\n        draw_control.circle = {}\n        draw_control.polyline = {}\n        draw_control.marker = {}\n        self.draw_control = draw_control\n\n        output = widgets.Output()\n        display(output)\n\n        def handle_draw(event_dict):\n            geo_json = event_dict.get(\"geo_json\")\n            if not geo_json:\n                print(\"No geometry found.\")\n                return\n\n            coords = geo_json['geometry']['coordinates'][0]\n            lon_min = min(pt[0] for pt in coords)\n            lon_max = max(pt[0] for pt in coords)\n            lat_min = min(pt[1] for pt in coords)\n            lat_max = max(pt[1] for pt in coords)\n\n            # Create bounding box from drawn rectangle\n            bbox = ee.Geometry.BBox(lon_min, lat_min, lon_max, lat_max)\n            self.bbox = bbox  # \u2705 Fix: Store for later use\n\n            # Run flood if elevation threshold provided\n            if elevation_threshold is not None:\n                flood_mask = hydro.simulate_flood(bbox, elevation_threshold)\n\n            self.add_ee_layer(flood_mask, vis_params={\"palette\": [\"0000FF\"]}, name=\"Simulated Flood\")\n\n\n            # Optionally chain to watershed mode\n            if post_action == \"Watershed\":\n                print(\"Bounding box captured. Activating watershed tool...\")\n                self.enable_draw_pour_point(bbox, accumulation_threshold=accumulation_threshold)\n\n\n            self.add_ee_layer(flood_mask, vis_params={\"palette\": [\"0000FF\"]}, name=\"Simulated Flood\")\n            self.remove_control(draw_control)\n\n            with output:\n                output.clear_output()\n                print(\"Flood simulation complete.\")\n\n            if post_action == \"Watershed\":\n                print(\"Bounding box captured. Activating watershed tool...\")\n                self.enable_draw_pour_point(self.bbox, accumulation_threshold=accumulation_threshold)\n\n        # \u2705 Wrapper that absorbs either style\n        def draw_wrapper(*args, **kwargs):\n            if args and isinstance(args[0], dict):\n                handle_draw(args[0])  # called with a single event dict\n            else:\n                handle_draw(kwargs)  # called with keyword arguments (action=..., geo_json=...)\n\n        draw_control.on_draw(draw_wrapper)\n        self.add_control(draw_control)\n\n\n\n\n\n    def on_draw(self, callback):\n        \"\"\"\n        Register a callback function to be triggered on draw events.\n\n        Parameters\n        ----------\n        callback : function\n            A function that receives the draw event GeoJSON dictionary.\n        \"\"\"\n        if hasattr(self, 'draw_control'):\n            def safe_callback(event):\n                geo_json = event.get('geo_json')\n                if geo_json:\n                    callback(geo_json)\n            self.draw_control.on_draw(safe_callback)\n        else:\n            raise AttributeError(\"Draw control not initialized. Call `add_draw_control()` first.\")\n\n\n    def show_watershed(self, bbox, pour_point):\n        from .hydro import delineate_watershed_gee\n        try:\n            watershed_fc = delineate_watershed_gee(bbox, pour_point)\n            self.add_ee_layer(watershed_fc, {\"color\": \"blue\"}, \"Watershed\")\n            self.add_ee_layer(ee.Geometry.Point(pour_point), {\"color\": \"red\"}, \"Pour Point\")\n        except Exception as e:\n            print(f\"Error delineating watershed: {e}\")\n\n    def enable_mode_toggle(self, default_mode=\"Flood\", elevation_threshold=10, accumulation_threshold=1000):\n        \"\"\"\n        Create a toggle UI to switch between flood simulation and watershed delineation,\n        with buttons to clear layers and reset the map.\n\n        Parameters\n        ----------\n        default_mode : str\n            Either 'Flood' or 'Watershed'\n        elevation_threshold : float\n            Elevation threshold for flood simulation\n        accumulation_threshold : int\n            Accumulation threshold for watershed delineation\n        \"\"\"\n        import ipywidgets as widgets\n        from IPython.display import display\n\n        # Create mode toggle buttons\n        mode_selector = widgets.ToggleButtons(\n            options=[\"Flood\", \"Watershed\"],\n            description=\"\",\n            value=default_mode,\n            button_style='info',\n            tooltips=[\"Simulate flood zones\", \"Delineate watershed\"]\n        )\n\n        threshold_slider = widgets.IntSlider(\n            value=elevation_threshold,\n            min=0,\n            max=200,\n            step=1,\n            description='Threshold (m):',\n            continuous_update=False,\n            style={'description_width': 'initial'}\n        )\n\n        # Clear and Reset buttons\n        clear_button = widgets.Button(description=\"\ud83e\uddf9 Clear Layers\", button_style=\"warning\")\n        reset_button = widgets.Button(description=\"\ud83d\udd04 Reset Map\", button_style=\"danger\")\n\n        # Output display\n        output = widgets.Output()\n\n        def on_mode_change(change):\n            if change['name'] == 'value':\n                with output:\n                    output.clear_output()\n                    print(f\"Switched to {change['new']} mode.\")\n\n                if change['new'] == \"Flood\":\n                    threshold = threshold_slider.value  # \u2705 get slider value\n                    with output:\n                        output.clear_output()\n                        print(f\"Simulating flood with threshold: {threshold}m\")\n                    threshold = threshold_slider.value\n                    print(f\"Passing threshold from slider: {threshold}m\")\n                    self.enable_draw_bbox(elevation_threshold=threshold)\n\n                elif change['new'] == \"Watershed\":\n                    if hasattr(self, \"bbox\"):\n                        self.enable_draw_pour_point(self.bbox, accumulation_threshold=accumulation_threshold)\n                    else:\n                        with output:\n                            output.clear_output()\n                            print(\"Draw a box to define your watershed area.\")\n                        self.enable_draw_bbox(elevation_threshold=None, post_action=\"Watershed\", accumulation_threshold=accumulation_threshold)\n\n        def on_clear_clicked(b):\n            self.clear_layers()\n            with output:\n                output.clear_output()\n                print(\"Cleared all layers.\")\n\n        def on_reset_clicked(b):\n            self.reset_map()\n            with output:\n                output.clear_output()\n                print(\"Map reset (layers, bbox, and draw tools cleared).\")\n            # Re-enable the current mode (default to Flood if none active)\n            if hasattr(self, \"mode\") and self.mode == \"Watershed\":\n                if hasattr(self, \"bbox\"):\n                    self.enable_draw_pour_point(self.bbox)\n                else:\n                    self.enable_draw_bbox(elevation_threshold=None, post_action=\"Watershed\")\n            else:\n                # Default back to Flood mode using the slider (if it exists)\n                try:\n                    self.enable_draw_bbox(elevation_threshold=self.threshold_slider.value)\n                except:\n                    self.enable_draw_bbox(elevation_threshold=10)\n\n\n        # Attach event listeners\n        mode_selector.observe(on_mode_change)\n        clear_button.on_click(on_clear_clicked)\n        reset_button.on_click(on_reset_clicked)\n\n        # Layout: Mode toggle + control buttons\n        ui = widgets.VBox([\n            widgets.HBox([mode_selector, clear_button, reset_button]),\n            threshold_slider,\n            output\n        ])\n        display(ui)\n\n        # Automatically load draw tool for default mode\n        if default_mode == \"Flood\":\n            self.enable_draw_bbox(elevation_threshold=threshold_slider.value)\n        elif default_mode == \"Watershed\":\n            if hasattr(self, \"bbox\"):\n                self.enable_draw_pour_point(self.bbox, accumulation_threshold=accumulation_threshold)\n            else:\n                print(\"Draw a bounding box first to begin watershed delineation.\")\n                self.enable_draw_bbox(\n                    elevation_threshold=None,\n                    post_action=\"Watershed\",\n                    accumulation_threshold=accumulation_threshold\n                )\n\n\n\n    def clear_layers(self):\n        \"\"\"\n        Removes all layers from the map except the base layer(s).\n        \"\"\"\n        base_layers = [layer for layer in self.layers if getattr(layer, 'base', False)]\n\n        # \u2705 Use super() to avoid recursion\n        super().clear_layers()\n\n        # Re-add preserved basemap(s)\n        for layer in base_layers:\n            self.add_layer(layer)\n\n\n\n    def reset_map(self):\n        \"\"\"\n        Fully resets the map: clears layers, removes draw controls, resets bbox and tools.\n        \"\"\"\n        self.clear_layers()\n        if hasattr(self, \"draw_control\") and self.draw_control in self.controls:\n            self.remove_control(self.draw_control)\n\n        if hasattr(self, \"bbox\"):\n            del self.bbox\n\n        self.add_layer_control()\n\n    def enable_draw_pour_point(self, bbox, accumulation_threshold=1000):\n        \"\"\"\n        Enable interactive pour point selection for watershed delineation.\n        \"\"\"\n        from ipyleaflet import DrawControl\n        import ipywidgets as widgets\n        from IPython.display import display\n        from . import hydro\n\n        # Remove any existing draw controls\n        if hasattr(self, 'draw_control') and self.draw_control in self.controls:\n            self.remove_control(self.draw_control)\n\n        draw_control = DrawControl(marker={\"shapeOptions\": {\"color\": \"#FF0000\"}})\n        draw_control.circle = {}\n        draw_control.polygon = {}\n        draw_control.polyline = {}\n        draw_control.rectangle = {}\n        self.draw_control = draw_control\n\n        output = widgets.Output()\n        display(output)\n\n        def handle_draw(event_dict):\n            geo_json = event_dict.get(\"geo_json\")\n            if not geo_json:\n                print(\"No geometry found.\")\n                return\n\n            coords = geo_json['geometry']['coordinates']\n            lon, lat = coords  # For a marker, it's a flat lon-lat pair\n            pour_point = [lon, lat]\n\n            try:\n                self.show_watershed(bbox, pour_point)\n                with output:\n                    output.clear_output()\n                    print(\"Watershed delineation complete.\")\n            except Exception as e:\n                with output:\n                    output.clear_output()\n                    print(f\"Error delineating watershed: {e}\")\n\n            self.remove_control(draw_control)\n\n        draw_control.on_draw(handle_draw)\n        self.add_control(draw_control)\n        print(\"\u2705 Pour point draw tool activated\")\n\n    def ensure_layer_control(self):\n        # Remove any existing LayerControl safely\n        for control in list(self.controls):  # use list() to avoid mutation error\n            if isinstance(control, LayersControl):\n                self.remove_control(control)\n        self.add_layer_control()\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.__init__","title":"<code>__init__(center, zoom=12, **kwargs)</code>","text":"<p>Initialize the custom map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>tuple</code> <p>Latitude and longitude of the map center.</p> required <code>zoom</code> <code>int</code> <p>Zoom level of the map. Defaults to 12.</p> <code>12</code> <code>**kwargs</code> <p>Additional keyword arguments for ipyleaflet.Map.</p> <code>{}</code> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>def __init__(self, center, zoom=12, **kwargs):\n    \"\"\"\n    Initialize the custom map.\n\n    Args:\n        center (tuple): Latitude and longitude of the map center.\n        zoom (int, optional): Zoom level of the map. Defaults to 12.\n        **kwargs: Additional keyword arguments for ipyleaflet.Map.\n    \"\"\"\n    kwargs.setdefault(\"scroll_wheel_zoom\", True)\n    super().__init__(center=center, zoom=zoom, **kwargs)\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.add_basemap","title":"<code>add_basemap(basemap_name)</code>","text":"<p>Add a basemap layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap_name</code> <code>str</code> <p>Name of the basemap ('OpenStreetMap', 'Esri.WorldImagery', or 'OpenTopoMap').</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the basemap name is not supported.</p> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>def add_basemap(self, basemap_name: str):\n    \"\"\"\n    Add a basemap layer to the map.\n\n    Args:\n        basemap_name (str): Name of the basemap ('OpenStreetMap', 'Esri.WorldImagery', or 'OpenTopoMap').\n\n    Raises:\n        ValueError: If the basemap name is not supported.\n    \"\"\"\n    basemap_urls = {\n        \"OpenStreetMap\": \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\",\n        \"Esri.WorldImagery\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n        \"OpenTopoMap\": \"https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png\"\n    }\n\n    if basemap_name not in basemap_urls:\n        raise ValueError(f\"Basemap '{basemap_name}' is not supported.\")\n\n    basemap = TileLayer(url=basemap_urls[basemap_name])\n    self.add_layer(basemap)\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.add_basemap_gui","title":"<code>add_basemap_gui(options=None, position='topright')</code>","text":"<p>Adds a graphical user interface (GUI) for selecting basemaps.</p> <p>Parameters:</p> Name Type Description Default <code>-options</code> <code>list</code> <p>A list of basemap options to display in the dropdown. [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"CartoDB.DarkMatter\"].</p> required <code>-position</code> <code>str</code> <p>The position of the widget on the map. Defaults to \"topright\".</p> required Behavior <ul> <li>A toggle button is used to show or hide the dropdown and close button.</li> <li>The dropdown allows users to select a bsemap from the provided options.</li> <li>The close button hides the widget from the map.</li> </ul> Event Handlers <ul> <li><code>on_toggle_change</code>: Toggles the visibility of the dropdown and close button.</li> <li><code>on_button_click</code>: Closes the widget when button is clicked</li> <li><code>on_dropdown_change</code>: Updates the basemap when a new option is selected.</li> </ul> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>def add_basemap_gui(self, options=None, position=\"topright\"):    \n    \"\"\"\n    Adds a graphical user interface (GUI) for selecting basemaps.\n\n    Args:\n        -options (list, optional): A list of basemap options to display in the dropdown.\n           [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"CartoDB.DarkMatter\"].\n        -position (str, optional): The position of the widget on the map. Defaults to \"topright\".\n\n    Behavior:\n        - A toggle button is used to show or hide the dropdown and close button.\n        - The dropdown allows users to select a bsemap from the provided options.\n        - The close button hides the widget from the map.\n\n    Event Handlers:\n        - `on_toggle_change`: Toggles the visibility of the dropdown and close button.\n        - `on_button_click`: Closes the widget when button is clicked\n        - `on_dropdown_change`: Updates the basemap when a new option is selected.\n    \"\"\"\n    if options is None:\n        options = [\n            \"OpenStreetMap.Mapnik\",\n            \"OpenTopoMap\",\n            \"Esri.WorldImagery\",\n            \"CartoDB.DarkMatter\",\n        ]\n\n    toggle = widgets.ToggleButton(\n        value=True,\n        button_style=\"\",\n        tooltip=\"Click me\",\n        icon=\"map\",\n    )\n    toggle.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n    dropdown = widgets.Dropdown(\n        options=options,\n        value=options[0],\n        description=\"Basemap:\",\n        style={\"description_width\": \"initial\"},\n    )\n    dropdown.layout = widgets.Layout(width=\"250px\", height=\"38px\")\n\n    button = widgets.Button(\n        icon=\"times\",\n    )\n    button.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n    hbox = widgets.HBox([toggle, dropdown, button])\n\n    def on_toggle_change(change):\n        if change[\"new\"]:\n            hbox.children = [toggle, dropdown, button]\n        else:\n            hbox.children = [toggle]\n\n    toggle.observe(on_toggle_change, names=\"value\")\n\n    def on_button_click(b):\n        hbox.close()\n        toggle.close()\n        dropdown.close()\n        button.close()\n\n    button.on_click(on_button_click)\n\n    def on_dropdown_change(change):\n        if change[\"new\"]:\n            self.layers = self.layers[:-2]\n            self.add_basemap(change[\"new\"])\n\n    dropdown.observe(on_dropdown_change, names=\"value\")\n\n    control = WidgetControl(widget=hbox, position=position)\n    self.add(control)\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.add_building_polygons","title":"<code>add_building_polygons(url)</code>","text":"<p>Add building polygons with red outline and no fill.</p> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>def add_building_polygons(self, url):\n    \"\"\"\n    Add building polygons with red outline and no fill.\n    \"\"\"\n    gdf = gpd.read_file(url)\n    geo_json = gdf.__geo_interface__\n\n    style = {\n        \"color\": \"red\",\n        \"weight\": 1,\n        \"fill\": False,\n        \"fillOpacity\": 0.0\n    }\n\n    self.add_layer(GeoJSON(data=geo_json, style=style, name=\"Buildings\"))\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.add_choropleth","title":"<code>add_choropleth(url, column, colormap='YlOrRd')</code>","text":"<p>Simulate a choropleth using GeoJSON layer and dynamic styling.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>GeoJSON file URL.</p> required <code>column</code> <code>str</code> <p>Attribute column to color by.</p> required <code>colormap</code> <code>str</code> <p>Color ramp name (from branca.colormap).</p> <code>'YlOrRd'</code> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>def add_choropleth(self, url, column, colormap=\"YlOrRd\"):\n    \"\"\"\n    Simulate a choropleth using GeoJSON layer and dynamic styling.\n\n    Args:\n        url (str): GeoJSON file URL.\n        column (str): Attribute column to color by.\n        colormap (str): Color ramp name (from branca.colormap).\n    \"\"\"\n    import branca.colormap as cm\n    import json\n\n    gdf = gpd.read_file(url)\n    gdf = gdf.to_crs(\"EPSG:4326\")\n    gdf[\"id\"] = gdf.index.astype(str)\n\n    values = gdf[column]\n    cmap = cm.linear.__getattribute__(colormap).scale(values.min(), values.max())\n\n    def style_dict(feature):\n        value = gdf.loc[int(feature['id']), column]\n        return {\n            'fillColor': cmap(value),\n            'color': 'black',\n            'weight': 0.5,\n            'fillOpacity': 0.7\n        }\n\n    geo_json = json.loads(gdf.to_json())\n    layer = GeoJSON(\n        data=geo_json,\n        style={\n            'color': 'black',\n            'fillColor': 'blue',\n            'weight': 0.5,\n            'fillOpacity': 0.7\n        },\n        name=\"Choropleth\"\n    )\n    self.add_layer(layer)\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.add_circle_markers_from_xy","title":"<code>add_circle_markers_from_xy(gdf, radius=5, color='red', fill_color='yellow', fill_opacity=0.8)</code>","text":"<p>Add circle markers from a GeoDataFrame with lat/lon columns using MarkerCluster.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>Must contain 'latitude' and 'longitude' columns.</p> required <code>radius</code> <code>int</code> <p>Radius of each marker.</p> <code>5</code> <code>color</code> <code>str</code> <p>Outline color.</p> <code>'red'</code> <code>fill_color</code> <code>str</code> <p>Fill color.</p> <code>'yellow'</code> <code>fill_opacity</code> <code>float</code> <p>Fill opacity.</p> <code>0.8</code> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>def add_circle_markers_from_xy(self, gdf, radius=5, color=\"red\", fill_color=\"yellow\", fill_opacity=0.8):\n    \"\"\"\n    Add circle markers from a GeoDataFrame with lat/lon columns using MarkerCluster.\n\n    Args:\n        gdf (GeoDataFrame): Must contain 'latitude' and 'longitude' columns.\n        radius (int): Radius of each marker.\n        color (str): Outline color.\n        fill_color (str): Fill color.\n        fill_opacity (float): Fill opacity.\n    \"\"\"\n    if 'latitude' not in gdf.columns or 'longitude' not in gdf.columns:\n        raise ValueError(\"GeoDataFrame must contain 'latitude' and 'longitude' columns\")\n\n    markers = []\n    for _, row in gdf.iterrows():\n        marker = CircleMarker(\n            location=(row['latitude'], row['longitude']),\n            radius=radius,\n            color=color,\n            fill_color=fill_color,\n            fill_opacity=fill_opacity,\n            stroke=True\n        )\n        markers.append(marker)\n\n    cluster = MarkerCluster(markers=markers)\n    self.add_layer(cluster)\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.add_ee_layer","title":"<code>add_ee_layer(ee_object, vis_params=None, name=None)</code>","text":"<p>Add an Earth Engine object to the ipyleaflet map.</p>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.add_ee_layer--parameters","title":"Parameters","text":"<p>ee_object : ee.Image or ee.FeatureCollection     The Earth Engine object to display. vis_params : dict, optional     Visualization parameters. name : str, optional     Layer name for the legend and layer control.</p> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>def add_ee_layer(self, ee_object, vis_params=None, name=None):\n    \"\"\"\n    Add an Earth Engine object to the ipyleaflet map.\n\n    Parameters\n    ----------\n    ee_object : ee.Image or ee.FeatureCollection\n        The Earth Engine object to display.\n    vis_params : dict, optional\n        Visualization parameters.\n    name : str, optional\n        Layer name for the legend and layer control.\n    \"\"\"\n    import geemap\n    layer = geemap.ee_tile_layer(ee_object, vis_params, name)\n    self.add_layer(layer)\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.add_image","title":"<code>add_image(url, bounds, opacity=1.0)</code>","text":"<p>Add an image overlay to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the image.</p> required <code>bounds</code> <code>list</code> <p>Bounding box of the image [[south, west], [north, east]].</p> required <code>opacity</code> <code>float</code> <p>Opacity of the image. Defaults to 1.0.</p> <code>1.0</code> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>def add_image(self, url, bounds, opacity=1.0):\n    \"\"\"\n    Add an image overlay to the map.\n\n    Args:\n        url (str): URL of the image.\n        bounds (list): Bounding box of the image [[south, west], [north, east]].\n        opacity (float, optional): Opacity of the image. Defaults to 1.0.\n    \"\"\"\n    image_layer = ImageOverlay(\n        url=url,\n        bounds=bounds,\n        opacity=opacity\n    )\n    self.add_layer(image_layer)\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.add_raster","title":"<code>add_raster(url, name=None, colormap=None, opacity=1.0)</code>","text":"<p>Add a raster tile layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL template for the raster tiles.</p> required <code>name</code> <code>str</code> <p>Layer name. Defaults to \"Raster Layer\".</p> <code>None</code> <code>colormap</code> <code>optional</code> <p>Colormap to apply (not used here but reserved).</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Opacity of the layer (0.0 to 1.0). Defaults to 1.0.</p> <code>1.0</code> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>def add_raster(self, url, name=None, colormap=None, opacity=1.0):\n    \"\"\"\n    Add a raster tile layer to the map.\n\n    Args:\n        url (str): URL template for the raster tiles.\n        name (str, optional): Layer name. Defaults to \"Raster Layer\".\n        colormap (optional): Colormap to apply (not used here but reserved).\n        opacity (float, optional): Opacity of the layer (0.0 to 1.0). Defaults to 1.0.\n    \"\"\"\n    tile_layer = TileLayer(\n        url=url,\n        name=name or \"Raster Layer\",\n        opacity=opacity\n    )\n    self.add_layer(tile_layer)\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.add_roads","title":"<code>add_roads(url)</code>","text":"<p>Add road polylines with red color and width 2.</p> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>def add_roads(self, url):\n    \"\"\"\n    Add road polylines with red color and width 2.\n    \"\"\"\n    gdf = gpd.read_file(url)\n    geo_json = gdf.__geo_interface__\n\n    style = {\n        \"color\": \"red\",\n        \"weight\": 2,\n        \"opacity\": 1.0\n    }\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.add_search_control","title":"<code>add_search_control(position='topleft', zoom=10)</code>","text":"<p>Add a search bar to the map using Nominatim geocoder.</p> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>def add_search_control(self, position=\"topleft\", zoom=10):\n    \"\"\"\n    Add a search bar to the map using Nominatim geocoder.\n    \"\"\"\n    search = SearchControl(\n        position=position,\n        url='https://nominatim.openstreetmap.org/search?format=json&amp;q={s}',\n        zoom=zoom,\n        marker=Marker()  # \u2705 Provide a valid Marker object\n    )\n    self.add_control(search)\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.add_split_rasters_leafmap","title":"<code>add_split_rasters_leafmap(pre_url, post_url, pre_name='Pre-event', post_name='Post-event', overwrite=True)</code>","text":"<p>Use leafmap to split and visualize two remote raster .tif files.</p> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>def add_split_rasters_leafmap(self, pre_url, post_url, pre_name=\"Pre-event\", post_name=\"Post-event\", overwrite=True):\n    \"\"\"\n    Use leafmap to split and visualize two remote raster .tif files.\n    \"\"\"\n    import leafmap\n    import rasterio\n    import os\n\n    def download_and_check(url, path):\n        file = leafmap.download_file(url, path, overwrite=overwrite)  # \u2705 Ensure overwrite is passed here\n        try:\n            with rasterio.open(file) as src:\n                _ = src.meta\n            return file\n        except Exception as e:\n            raise ValueError(f\"{path} is not a valid GeoTIFF: {e}\")\n\n    pre_tif = download_and_check(pre_url, \"pre_event.tif\")\n    post_tif = download_and_check(post_url, \"post_event.tif\")\n\n    m = leafmap.Map(center=self.center, zoom=self.zoom)\n    m.split_map(left_layer=pre_tif, right_layer=post_tif, left_label=pre_name, right_label=post_name)\n    return m\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.add_vector","title":"<code>add_vector(vector_data)</code>","text":"<p>Add a vector layer to the map from a file path or GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>vector_data</code> <code>str or GeoDataFrame</code> <p>Path to a vector file or a GeoDataFrame.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input is not a valid file path or GeoDataFrame.</p> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>def add_vector(self, vector_data):\n    \"\"\"\n    Add a vector layer to the map from a file path or GeoDataFrame.\n\n    Args:\n        vector_data (str or geopandas.GeoDataFrame): Path to a vector file or a GeoDataFrame.\n\n    Raises:\n        ValueError: If the input is not a valid file path or GeoDataFrame.\n    \"\"\"\n    if isinstance(vector_data, str):\n        gdf = gpd.read_file(vector_data)\n    elif isinstance(vector_data, gpd.GeoDataFrame):\n        gdf = vector_data\n    else:\n        raise ValueError(\"Input must be a file path or a GeoDataFrame.\")\n\n    geo_json_data = gdf.__geo_interface__\n    geo_json_layer = GeoJSON(data=geo_json_data)\n    self.add_layer(geo_json_layer)\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.add_video","title":"<code>add_video(url, bounds, opacity=1.0)</code>","text":"<p>Add a video overlay to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the video.</p> required <code>bounds</code> <code>list</code> <p>Bounding box for the video [[south, west], [north, east]].</p> required <code>opacity</code> <code>float</code> <p>Opacity of the video. Defaults to 1.0.</p> <code>1.0</code> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>def add_video(self, url, bounds, opacity=1.0):\n    \"\"\"\n    Add a video overlay to the map.\n\n    Args:\n        url (str): URL of the video.\n        bounds (list): Bounding box for the video [[south, west], [north, east]].\n        opacity (float, optional): Opacity of the video. Defaults to 1.0.\n    \"\"\"\n    video_layer = VideoOverlay(\n        url=url,\n        bounds=bounds,\n        opacity=opacity\n    )\n    self.add_layer(video_layer)\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.add_widget","title":"<code>add_widget(widget, position='topright', **kwargs)</code>","text":"<p>Add a widget to the map.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>Widget</code> <p>The widget to add.</p> required <code>position</code> <code>str</code> <p>Position of the widget. Defaults to \"topright\".</p> <code>'topright'</code> <code>**kwargs</code> <p>Additional keyword arguments for the WidgetControl.</p> <code>{}</code> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>def add_widget(self, widget, position=\"topright\", **kwargs):\n    \"\"\"Add a widget to the map.\n\n    Args:\n        widget (ipywidgets.Widget): The widget to add.\n        position (str, optional): Position of the widget. Defaults to \"topright\".\n        **kwargs: Additional keyword arguments for the WidgetControl.\n    \"\"\"\n    control = ipyleaflet.WidgetControl(widget=widget, position=position, **kwargs)\n    self.add(control)\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.add_wms_layer","title":"<code>add_wms_layer(url, layers, name=None, format='image/png', transparent=True, **extra_params)</code>","text":"<p>Add a WMS (Web Map Service) layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>WMS base URL.</p> required <code>layers</code> <code>str</code> <p>Comma-separated list of layer names.</p> required <code>name</code> <code>str</code> <p>Display name for the layer. Defaults to \"WMS Layer\".</p> <code>None</code> <code>format</code> <code>str</code> <p>Image format. Defaults to 'image/png'.</p> <code>'image/png'</code> <code>transparent</code> <code>bool</code> <p>Whether the background is transparent. Defaults to True.</p> <code>True</code> <code>**extra_params</code> <p>Additional parameters to pass to the WMSLayer.</p> <code>{}</code> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>def add_wms_layer(self, url, layers, name=None, format='image/png', transparent=True, **extra_params):\n    \"\"\"\n    Add a WMS (Web Map Service) layer to the map.\n\n    Args:\n        url (str): WMS base URL.\n        layers (str): Comma-separated list of layer names.\n        name (str, optional): Display name for the layer. Defaults to \"WMS Layer\".\n        format (str, optional): Image format. Defaults to 'image/png'.\n        transparent (bool, optional): Whether the background is transparent. Defaults to True.\n        **extra_params: Additional parameters to pass to the WMSLayer.\n    \"\"\"\n    wms_layer = WMSLayer(\n        url=url,\n        layers=layers,\n        name=name or \"WMS Layer\",\n        format=format,\n        transparent=transparent,\n        **extra_params\n    )\n    self.add_layer(wms_layer)\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.clear_layers","title":"<code>clear_layers()</code>","text":"<p>Removes all layers from the map except the base layer(s).</p> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>def clear_layers(self):\n    \"\"\"\n    Removes all layers from the map except the base layer(s).\n    \"\"\"\n    base_layers = [layer for layer in self.layers if getattr(layer, 'base', False)]\n\n    # \u2705 Use super() to avoid recursion\n    super().clear_layers()\n\n    # Re-add preserved basemap(s)\n    for layer in base_layers:\n        self.add_layer(layer)\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.enable_draw_pour_point","title":"<code>enable_draw_pour_point(bbox, accumulation_threshold=1000)</code>","text":"<p>Enable interactive pour point selection for watershed delineation.</p> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>def enable_draw_pour_point(self, bbox, accumulation_threshold=1000):\n    \"\"\"\n    Enable interactive pour point selection for watershed delineation.\n    \"\"\"\n    from ipyleaflet import DrawControl\n    import ipywidgets as widgets\n    from IPython.display import display\n    from . import hydro\n\n    # Remove any existing draw controls\n    if hasattr(self, 'draw_control') and self.draw_control in self.controls:\n        self.remove_control(self.draw_control)\n\n    draw_control = DrawControl(marker={\"shapeOptions\": {\"color\": \"#FF0000\"}})\n    draw_control.circle = {}\n    draw_control.polygon = {}\n    draw_control.polyline = {}\n    draw_control.rectangle = {}\n    self.draw_control = draw_control\n\n    output = widgets.Output()\n    display(output)\n\n    def handle_draw(event_dict):\n        geo_json = event_dict.get(\"geo_json\")\n        if not geo_json:\n            print(\"No geometry found.\")\n            return\n\n        coords = geo_json['geometry']['coordinates']\n        lon, lat = coords  # For a marker, it's a flat lon-lat pair\n        pour_point = [lon, lat]\n\n        try:\n            self.show_watershed(bbox, pour_point)\n            with output:\n                output.clear_output()\n                print(\"Watershed delineation complete.\")\n        except Exception as e:\n            with output:\n                output.clear_output()\n                print(f\"Error delineating watershed: {e}\")\n\n        self.remove_control(draw_control)\n\n    draw_control.on_draw(handle_draw)\n    self.add_control(draw_control)\n    print(\"\u2705 Pour point draw tool activated\")\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.enable_mode_toggle","title":"<code>enable_mode_toggle(default_mode='Flood', elevation_threshold=10, accumulation_threshold=1000)</code>","text":"<p>Create a toggle UI to switch between flood simulation and watershed delineation, with buttons to clear layers and reset the map.</p>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.enable_mode_toggle--parameters","title":"Parameters","text":"<p>default_mode : str     Either 'Flood' or 'Watershed' elevation_threshold : float     Elevation threshold for flood simulation accumulation_threshold : int     Accumulation threshold for watershed delineation</p> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>def enable_mode_toggle(self, default_mode=\"Flood\", elevation_threshold=10, accumulation_threshold=1000):\n    \"\"\"\n    Create a toggle UI to switch between flood simulation and watershed delineation,\n    with buttons to clear layers and reset the map.\n\n    Parameters\n    ----------\n    default_mode : str\n        Either 'Flood' or 'Watershed'\n    elevation_threshold : float\n        Elevation threshold for flood simulation\n    accumulation_threshold : int\n        Accumulation threshold for watershed delineation\n    \"\"\"\n    import ipywidgets as widgets\n    from IPython.display import display\n\n    # Create mode toggle buttons\n    mode_selector = widgets.ToggleButtons(\n        options=[\"Flood\", \"Watershed\"],\n        description=\"\",\n        value=default_mode,\n        button_style='info',\n        tooltips=[\"Simulate flood zones\", \"Delineate watershed\"]\n    )\n\n    threshold_slider = widgets.IntSlider(\n        value=elevation_threshold,\n        min=0,\n        max=200,\n        step=1,\n        description='Threshold (m):',\n        continuous_update=False,\n        style={'description_width': 'initial'}\n    )\n\n    # Clear and Reset buttons\n    clear_button = widgets.Button(description=\"\ud83e\uddf9 Clear Layers\", button_style=\"warning\")\n    reset_button = widgets.Button(description=\"\ud83d\udd04 Reset Map\", button_style=\"danger\")\n\n    # Output display\n    output = widgets.Output()\n\n    def on_mode_change(change):\n        if change['name'] == 'value':\n            with output:\n                output.clear_output()\n                print(f\"Switched to {change['new']} mode.\")\n\n            if change['new'] == \"Flood\":\n                threshold = threshold_slider.value  # \u2705 get slider value\n                with output:\n                    output.clear_output()\n                    print(f\"Simulating flood with threshold: {threshold}m\")\n                threshold = threshold_slider.value\n                print(f\"Passing threshold from slider: {threshold}m\")\n                self.enable_draw_bbox(elevation_threshold=threshold)\n\n            elif change['new'] == \"Watershed\":\n                if hasattr(self, \"bbox\"):\n                    self.enable_draw_pour_point(self.bbox, accumulation_threshold=accumulation_threshold)\n                else:\n                    with output:\n                        output.clear_output()\n                        print(\"Draw a box to define your watershed area.\")\n                    self.enable_draw_bbox(elevation_threshold=None, post_action=\"Watershed\", accumulation_threshold=accumulation_threshold)\n\n    def on_clear_clicked(b):\n        self.clear_layers()\n        with output:\n            output.clear_output()\n            print(\"Cleared all layers.\")\n\n    def on_reset_clicked(b):\n        self.reset_map()\n        with output:\n            output.clear_output()\n            print(\"Map reset (layers, bbox, and draw tools cleared).\")\n        # Re-enable the current mode (default to Flood if none active)\n        if hasattr(self, \"mode\") and self.mode == \"Watershed\":\n            if hasattr(self, \"bbox\"):\n                self.enable_draw_pour_point(self.bbox)\n            else:\n                self.enable_draw_bbox(elevation_threshold=None, post_action=\"Watershed\")\n        else:\n            # Default back to Flood mode using the slider (if it exists)\n            try:\n                self.enable_draw_bbox(elevation_threshold=self.threshold_slider.value)\n            except:\n                self.enable_draw_bbox(elevation_threshold=10)\n\n\n    # Attach event listeners\n    mode_selector.observe(on_mode_change)\n    clear_button.on_click(on_clear_clicked)\n    reset_button.on_click(on_reset_clicked)\n\n    # Layout: Mode toggle + control buttons\n    ui = widgets.VBox([\n        widgets.HBox([mode_selector, clear_button, reset_button]),\n        threshold_slider,\n        output\n    ])\n    display(ui)\n\n    # Automatically load draw tool for default mode\n    if default_mode == \"Flood\":\n        self.enable_draw_bbox(elevation_threshold=threshold_slider.value)\n    elif default_mode == \"Watershed\":\n        if hasattr(self, \"bbox\"):\n            self.enable_draw_pour_point(self.bbox, accumulation_threshold=accumulation_threshold)\n        else:\n            print(\"Draw a bounding box first to begin watershed delineation.\")\n            self.enable_draw_bbox(\n                elevation_threshold=None,\n                post_action=\"Watershed\",\n                accumulation_threshold=accumulation_threshold\n            )\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.on_draw","title":"<code>on_draw(callback)</code>","text":"<p>Register a callback function to be triggered on draw events.</p>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.on_draw--parameters","title":"Parameters","text":"<p>callback : function     A function that receives the draw event GeoJSON dictionary.</p> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>def on_draw(self, callback):\n    \"\"\"\n    Register a callback function to be triggered on draw events.\n\n    Parameters\n    ----------\n    callback : function\n        A function that receives the draw event GeoJSON dictionary.\n    \"\"\"\n    if hasattr(self, 'draw_control'):\n        def safe_callback(event):\n            geo_json = event.get('geo_json')\n            if geo_json:\n                callback(geo_json)\n        self.draw_control.on_draw(safe_callback)\n    else:\n        raise AttributeError(\"Draw control not initialized. Call `add_draw_control()` first.\")\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.reset_map","title":"<code>reset_map()</code>","text":"<p>Fully resets the map: clears layers, removes draw controls, resets bbox and tools.</p> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>def reset_map(self):\n    \"\"\"\n    Fully resets the map: clears layers, removes draw controls, resets bbox and tools.\n    \"\"\"\n    self.clear_layers()\n    if hasattr(self, \"draw_control\") and self.draw_control in self.controls:\n        self.remove_control(self.draw_control)\n\n    if hasattr(self, \"bbox\"):\n        del self.bbox\n\n    self.add_layer_control()\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.gb_map.show_map","title":"<code>show_map()</code>","text":"<p>Display the map in a Jupyter notebook or compatible environment.</p> <p>Returns:</p> Type Description <p>ipyleaflet.Map: The configured map.</p> Source code in <code>GeoBay\\GeoBay.py</code> <pre><code>def show_map(self):\n    \"\"\"\n    Display the map in a Jupyter notebook or compatible environment.\n\n    Returns:\n        ipyleaflet.Map: The configured map.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"geobay/#GeoBay.GeoBay.delineate_watershed_gee","title":"<code>delineate_watershed_gee(bbox, pour_point, accumulation_threshold=1000)</code>","text":"<p>Returns the watershed polygon as an ee.FeatureCollection.</p> Source code in <code>GeoBay\\hydro.py</code> <pre><code>def delineate_watershed_gee(bbox, pour_point, accumulation_threshold=1000):\n    \"\"\"\n    Returns the watershed polygon as an ee.FeatureCollection.\n    \"\"\"\n    import ee\n\n    flow_acc = ee.Image(\"MERIT/Hydro/v1_0_1\").select(\"upa\").clip(bbox.buffer(500))\n    streams = flow_acc.gt(accumulation_threshold)\n\n    pt = ee.Geometry.Point(pour_point)\n    search_area = pt.buffer(300)\n    snapped = streams.reduceToVectors(\n        geometry=search_area,\n        geometryType='centroid',\n        scale=90,\n        maxPixels=1e8\n    ).geometry()\n\n    snapped_point = ee.Algorithms.If(snapped.isEmpty(), pt, snapped)\n    source = ee.Image().toByte().paint(ee.Geometry(snapped_point), 1)\n\n    watershed_mask = flow_acc.gte(accumulation_threshold).cumulativeCost(\n        source=source,\n        maxDistance=1e7\n    ).lt(500)\n\n    watershed_fc = watershed_mask.selfMask().reduceToVectors(\n        geometry=bbox,\n        scale=90,\n        geometryType='polygon',\n        maxPixels=1e8\n    )\n\n    return watershed_fc\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install Geobay, run this command in your terminal:</p> <pre><code>pip install geobay\n</code></pre> <p>This is the preferred method to install Geobay, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install Geobay from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/Caseyshea96/geobay\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use Geobay in a project:</p> <pre><code>import geobay\n</code></pre>"},{"location":"examples/Hydro_demo/","title":"Hydro demo","text":"In\u00a0[1]: Copied! <pre>import ee\nfrom GeoBay.GeoBay import gb_map\n\nee.Initialize()\n\n# Define a test bounding box (Mississippi River floodplain)\nbbox = ee.Geometry.BBox(-91.3, 30.1, -90.9, 30.6)\n\n# Create and show the map\nm = gb_map(center=[30.35, -91.1], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm.enable_mode_toggle()\n\nm.show_map()\n</pre> import ee from GeoBay.GeoBay import gb_map  ee.Initialize()  # Define a test bounding box (Mississippi River floodplain) bbox = ee.Geometry.BBox(-91.3, 30.1, -90.9, 30.6)  # Create and show the map m = gb_map(center=[30.35, -91.1], zoom=10) m.add_basemap(\"OpenStreetMap\") m.enable_mode_toggle()  m.show_map()  Out[1]: In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/SplitMap_demo/","title":"SplitMap demo","text":"In\u00a0[1]: Copied! <pre>from GeoBay.foliumap import FoliumMap  # If using as a module\n\n# Initialize the map\nmy_map = FoliumMap(location=(38.5, -98.0), zoom_start=5)\n\n# Add split map functionality\nmy_map.add_split_map('OpenStreetMap', 'Esri WorldImagery')\n\n# Optional: Add layer control\nmy_map.add_layer_control()\n\n# Show the map\nmy_map.show_map()\n</pre> from GeoBay.foliumap import FoliumMap  # If using as a module  # Initialize the map my_map = FoliumMap(location=(38.5, -98.0), zoom_start=5)  # Add split map functionality my_map.add_split_map('OpenStreetMap', 'Esri WorldImagery')  # Optional: Add layer control my_map.add_layer_control()  # Show the map my_map.show_map()   Out[1]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[\u00a0]: Copied! <pre>\n</pre>"}]}